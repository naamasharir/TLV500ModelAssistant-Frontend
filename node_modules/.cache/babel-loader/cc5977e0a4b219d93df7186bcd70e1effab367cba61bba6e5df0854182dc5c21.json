{"ast":null,"code":"'use client';\n\nimport _defineProperty from \"/Users/naamasharir/Documents/personal/TLV500ModelAssistant/TLV500-Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport * as React from 'react';\nimport useLazyRef from '@mui/utils/useLazyRef';\n/**\n * Lazy initialization container for the Ripple instance. This improves\n * performance by delaying mounting the ripple until it's needed.\n */\nexport class LazyRipple {\n  /** React ref to the ripple instance */\n\n  /** If the ripple component should be mounted */\n\n  /** Promise that resolves when the ripple component is mounted */\n\n  /** If the ripple component has been mounted */\n\n  /** React state hook setter */\n\n  static create() {\n    return new LazyRipple();\n  }\n  static use() {\n    /* eslint-disable */\n    const ripple = useLazyRef(LazyRipple.create).current;\n    const [shouldMount, setShouldMount] = React.useState(false);\n    ripple.shouldMount = shouldMount;\n    ripple.setShouldMount = setShouldMount;\n    React.useEffect(ripple.mountEffect, [shouldMount]);\n    /* eslint-enable */\n\n    return ripple;\n  }\n  constructor() {\n    _defineProperty(this, \"mountEffect\", () => {\n      if (this.shouldMount && !this.didMount) {\n        if (this.ref.current !== null) {\n          this.didMount = true;\n          this.mounted.resolve();\n        }\n      }\n    });\n    this.ref = {\n      current: null\n    };\n    this.mounted = null;\n    this.didMount = false;\n    this.shouldMount = false;\n    this.setShouldMount = null;\n  }\n  mount() {\n    if (!this.mounted) {\n      this.mounted = createControlledPromise();\n      this.shouldMount = true;\n      this.setShouldMount(this.shouldMount);\n    }\n    return this.mounted;\n  }\n  /* Ripple API */\n\n  start() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    this.mount().then(() => {\n      var _this$ref$current;\n      return (_this$ref$current = this.ref.current) === null || _this$ref$current === void 0 ? void 0 : _this$ref$current.start(...args);\n    });\n  }\n  stop() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    this.mount().then(() => {\n      var _this$ref$current2;\n      return (_this$ref$current2 = this.ref.current) === null || _this$ref$current2 === void 0 ? void 0 : _this$ref$current2.stop(...args);\n    });\n  }\n  pulsate() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    this.mount().then(() => {\n      var _this$ref$current3;\n      return (_this$ref$current3 = this.ref.current) === null || _this$ref$current3 === void 0 ? void 0 : _this$ref$current3.pulsate(...args);\n    });\n  }\n}\nexport default function useLazyRipple() {\n  return LazyRipple.use();\n}\nfunction createControlledPromise() {\n  let resolve;\n  let reject;\n  const p = new Promise((resolveFn, rejectFn) => {\n    resolve = resolveFn;\n    reject = rejectFn;\n  });\n  p.resolve = resolve;\n  p.reject = reject;\n  return p;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}