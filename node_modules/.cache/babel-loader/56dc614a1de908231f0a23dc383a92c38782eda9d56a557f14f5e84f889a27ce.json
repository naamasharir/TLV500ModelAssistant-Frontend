{"ast":null,"code":"import _objectSpread from \"/Users/naamasharir/Documents/personal/TLV500ModelAssistant/TLV500-Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _formatErrorMessage from \"@mui/utils/formatMuiErrorMessage\";\n/**\n * For using in `sx` prop to sort the breakpoint from low to high.\n * Note: this function does not work and will not support multiple units.\n *       e.g. input: { '@container (min-width:300px)': '1rem', '@container (min-width:40rem)': '2rem' }\n *            output: { '@container (min-width:40rem)': '2rem', '@container (min-width:300px)': '1rem' } // since 40 < 300 eventhough 40rem > 300px\n */\nexport function sortContainerQueries(theme, css) {\n  if (!theme.containerQueries) {\n    return css;\n  }\n  const sorted = Object.keys(css).filter(key => key.startsWith('@container')).sort((a, b) => {\n    var _a$match, _b$match;\n    const regex = /min-width:\\s*([0-9.]+)/;\n    return +(((_a$match = a.match(regex)) === null || _a$match === void 0 ? void 0 : _a$match[1]) || 0) - +(((_b$match = b.match(regex)) === null || _b$match === void 0 ? void 0 : _b$match[1]) || 0);\n  });\n  if (!sorted.length) {\n    return css;\n  }\n  return sorted.reduce((acc, key) => {\n    const value = css[key];\n    delete acc[key];\n    acc[key] = value;\n    return acc;\n  }, _objectSpread({}, css));\n}\nexport function isCqShorthand(breakpointKeys, value) {\n  return value === '@' || value.startsWith('@') && (breakpointKeys.some(key => value.startsWith(\"@\".concat(key))) || !!value.match(/^@\\d/));\n}\nexport function getContainerQuery(theme, shorthand) {\n  const matches = shorthand.match(/^@([^/]+)?\\/?(.+)?$/);\n  if (!matches) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(process.env.NODE_ENV !== \"production\" ? \"MUI: The provided shorthand \".concat(\"(\".concat(shorthand, \")\"), \" is invalid. The format should be `@<breakpoint | number>` or `@<breakpoint | number>/<container>`.\\n\") + 'For example, `@sm` or `@600` or `@40rem/sidebar`.' : _formatErrorMessage(18, \"(\".concat(shorthand, \")\")));\n    }\n    return null;\n  }\n  const [, containerQuery, containerName] = matches;\n  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;\n  return theme.containerQueries(containerName).up(value);\n}\nexport default function cssContainerQueries(themeInput) {\n  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace('@media', name ? \"@container \".concat(name) : '@container');\n  function attachCq(node, name) {\n    node.up = function () {\n      return toContainerQuery(themeInput.breakpoints.up(...arguments), name);\n    };\n    node.down = function () {\n      return toContainerQuery(themeInput.breakpoints.down(...arguments), name);\n    };\n    node.between = function () {\n      return toContainerQuery(themeInput.breakpoints.between(...arguments), name);\n    };\n    node.only = function () {\n      return toContainerQuery(themeInput.breakpoints.only(...arguments), name);\n    };\n    node.not = function () {\n      const result = toContainerQuery(themeInput.breakpoints.not(...arguments), name);\n      if (result.includes('not all and')) {\n        // `@container` does not work with `not all and`, so need to invert the logic\n        return result.replace('not all and ', '').replace('min-width:', 'width<').replace('max-width:', 'width>').replace('and', 'or');\n      }\n      return result;\n    };\n  }\n  const node = {};\n  const containerQueries = name => {\n    attachCq(node, name);\n    return node;\n  };\n  attachCq(containerQueries);\n  return _objectSpread(_objectSpread({}, themeInput), {}, {\n    containerQueries\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}